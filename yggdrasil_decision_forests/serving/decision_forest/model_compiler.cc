/*
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <memory>
#include <string>
#include <vector>

#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/escaping.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/substitute.h"
#include "yggdrasil_decision_forests/model/abstract_model.h"
#include "yggdrasil_decision_forests/model/gradient_boosted_trees/gradient_boosted_trees.h"
#include "yggdrasil_decision_forests/model/model_library.h"
#include "yggdrasil_decision_forests/serving/decision_forest/decision_forest.h"
#include "yggdrasil_decision_forests/utils/logging.h"
#include "yggdrasil_decision_forests/utils/status_macros.h"

namespace yggdrasil_decision_forests {
namespace serving {
namespace decision_forest {
namespace {
template <typename T>
std::string NumericalVecToString(const std::vector<T>& vec) {
  std::string str = "{";

  for (size_t i = 0; i < vec.size(); ++i) {
    if (i == vec.size() - 1) {
      absl::StrAppend(&str, vec[i]);
    } else {
      absl::StrAppend(&str, vec[i], ", ");
    }
  }
  absl::StrAppend(&str, "}");
  return str;
}
}  // namespace

absl::StatusOr<std::string> CompileRankingNumericalOnly(
    const std::string& model_path, const std::string& name_space) {
  YDF_LOG(INFO) << "Converting Model from " << model_path;
  STATUS_CHECK_NE(name_space, "");

  const std::string raw_model_file_contents = R"(
// This model was automatically generated by Yggdrasil Decision Forests.
// This is a precomiled version of a YDF model for minimal binary size.
// To use this model, you need to manually format your examples as float vectors
// and serve them to your model. See 
// yggdrasil_decision_forests/cli/compile_model_test.cc for an example.
//
// Do not use compiled models unless you have a strong need for small binary
// impact and know what you are doing.

#ifndef YGGDRASIL_DECISION_FORESTS_COMPILED_MODEL_H_
#define YGGDRASIL_DECISION_FORESTS_COMPILED_MODEL_H_

#include <string>
#include <utility>
#include <vector>

#include "absl/strings/escaping.h"
#include "absl/strings/string_view.h"
#include "yggdrasil_decision_forests/model/abstract_model.pb.h"
#include "yggdrasil_decision_forests/serving/decision_forest/decision_forest_serving.h"
#include "yggdrasil_decision_forests/utils/protobuf.h"

namespace yggdrasil_decision_forests {
namespace compiled_model {
namespace $0 {

absl::StatusOr<serving::FeaturesDefinitionNumericalOrCategoricalFlat>
CreateInternalFeatures(const std::vector<int>& input_features,
                       absl::string_view serialized_data_spec) {
  serving::FeaturesDefinitionNumericalOrCategoricalFlat internal_features;

  std::string data_spec_as_string;
  if (!absl::Base64Unescape(serialized_data_spec, &data_spec_as_string)) {
    return absl::InvalidArgumentError("data_spec could not be deserialized");
  }
  ASSIGN_OR_RETURN(auto data_spec,
                   utils::ParseBinaryProto<dataset::proto::DataSpecification>(
                       data_spec_as_string));
  RETURN_IF_ERROR(
      internal_features.Initialize(input_features, data_spec, false));
  return internal_features;
}

absl::StatusOr<model::proto::Metadata> CreateMetadata(
    absl::string_view serialized_metadata) {
  std::string metadata_as_string;
  if (!absl::Base64Unescape(serialized_metadata, &metadata_as_string)) {
    return absl::InvalidArgumentError("data_spec could not be deserialized");
  }
  ASSIGN_OR_RETURN(
      auto metadata,
      utils::ParseBinaryProto<model::proto::Metadata>(metadata_as_string));
  return metadata;
}

// Get a non-owning pointer to the pre-compiled model.
//
// The model can be used for predictions on flat example sets. The model lives
// on the heap and should its memory should not be freed since the underlying
// variable is static.
absl::StatusOr<const serving::decision_forest::
                   GradientBoostedTreesRankingNumericalOnly* const> GetModel() {
  ASSIGN_OR_RETURN(
      auto metadata,
      CreateMetadata($6));
  ASSIGN_OR_RETURN(
      auto internal_features, CreateInternalFeatures($4, $5));
  // This pointer will not be freed.
  static serving::decision_forest::
      GradientBoostedTreesRankingNumericalOnly* const model = [&metadata, &internal_features] {
        auto* model = new serving::decision_forest::
            GradientBoostedTreesRankingNumericalOnly();
        model->initial_predictions = $1;
        model->nodes = $2;
        model->root_offsets = $3;
        model->internal_features = std::move(internal_features);
        model->metadata = std::move(metadata);
        model->oblique_weights = $7;
        model->oblique_internal_feature_idxs = $8;
        return model;
      }();

  return model;
}

}  // namespace $0
}  // namespace compiled_model
}  // namespace yggdrasil_decision_forests

#endif  // YGGDRASIL_DECISION_FORESTS_COMPILED_MODEL_H_
)";

  std::unique_ptr<model::AbstractModel> loaded_model;
  RETURN_IF_ERROR(model::LoadModel(model_path, &loaded_model));
  serving::decision_forest::GradientBoostedTreesRankingNumericalOnly flat_model;
  auto* gbt_model =
      dynamic_cast<model::gradient_boosted_trees::GradientBoostedTreesModel*>(
          loaded_model.get());
  if (gbt_model == nullptr) {
    return absl::InvalidArgumentError(
        "Model compilation is only supported for Gradient Boosted Tree Models");
  }
  if (gbt_model->task() != model::proto::Task::RANKING) {
    return absl::InvalidArgumentError(
        "Model compilation is only supported for Ranking models");
  }
  // TODO: Add an explicit check that all features are numerical.
  RETURN_IF_ERROR(GenericToSpecializedModel(*gbt_model, &flat_model));
  YDF_LOG(INFO) << "Loaded model. Start compilation to "
                << "GradientBoostedTreesRankingNumericalOnly model";

  std::string model_nodes = "{";

  for (size_t i = 0; i < flat_model.nodes.size(); ++i) {
    const auto& node = flat_model.nodes[i];
    float threshold_or_label;
    if (node.right_idx == 0) {
      threshold_or_label = node.label;
    } else {
      threshold_or_label = node.threshold;
    }
    absl::StrAppend(&model_nodes,
                    absl::Substitute("{$0, $1, {$2}}", node.right_idx,
                                     node.feature_idx, threshold_or_label));
    if (i < flat_model.nodes.size() - 1) {
      absl::StrAppend(&model_nodes, ",\n  ");
    }
  }
  absl::StrAppend(&model_nodes, "}");

  const std::string model_root_offsets =
      NumericalVecToString(flat_model.root_offsets);

  const std::string model_oblique_internal_feature_idxs =
      NumericalVecToString(flat_model.oblique_internal_feature_idxs);

  const std::string model_oblique_weights =
      NumericalVecToString(flat_model.oblique_weights);

  const std::string model_internal_features =
      "  .internal_features = CreateInternalFeatures(\n";

  const std::string model_input_features = NumericalVecToString(
      flat_model.internal_features.column_input_features());

  const std::string model_data_spec = absl::Substitute(
      "\"$0\"",
      absl::Base64Escape(
          flat_model.internal_features.data_spec().SerializeAsString()));

  // Remove the owner name to prevent information leakage
  flat_model.metadata.set_owner("");
  const std::string model_metadata = absl::Substitute(
      "\"$0\"", absl::Base64Escape(flat_model.metadata.SerializeAsString()));

  const auto model_file_contents =
      absl::Substitute(raw_model_file_contents,
                       name_space,                          // $0
                       flat_model.initial_predictions,      // $1
                       model_nodes,                         // $2
                       model_root_offsets,                  // $3
                       model_input_features,                // $4
                       model_data_spec,                     // $5
                       model_metadata,                      // $6
                       model_oblique_weights,               // $7
                       model_oblique_internal_feature_idxs  // $8
      );

  YDF_LOG(INFO) << "Model compilation complete.";

  return model_file_contents;
}
}  // namespace decision_forest
}  // namespace serving
}  // namespace yggdrasil_decision_forests
